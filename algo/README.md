
# 链表

关于链表解题思路：

- 快慢指针
- 哨兵节点减少代码复杂度
- 注意链表的头尾边界
- 手动画出next节点的变化关系

**package list下：**

- LRUByLinkList：基于单向链表实现的LRU淘汰算法
- PalindromeByLinedList：基于链表实现的回文字符串检测
- ReservedLinkedList：反置链表
- MergeOrderLinkedList：两个有序链表合并
- RingInLinkedList：检测链表中是否有环
- RemoveNodeInLinkedList：删除链表中倒数第N个节点
- GetMidNodeInLinkedList：求链表的中间节点

# 栈

数组实现的栈成为顺序栈，链表实现的栈为链式栈。

**栈的应用场景**

- 函数调用
- 表达式求值
- 括号匹配
- 浏览器的前进后退（两个栈）

**表达式求值运用栈？**

对于加减乘除四则运算，我们人可以很清楚的知道如何计算，但是对于编译器来说并没有那么简单。编译器需要维护两个栈：

- 操作数栈
- 运算符栈

从左往右遍历表达式，遇到数字将其压入操作数栈，但当遇到运算符时需要将该运算符与栈顶的运算符进行比较：

- 如果该运算符比栈顶的优先级高，那么将运算符入栈
- 如果该运算符和栈顶的优先级相同或者比它第，就需要从运算符栈取出栈顶元素，然后从操作数栈取出两个操作数，进行计算，
将计算后的结果再压入操作数栈，继续比较


**package stack下：**

- ArrayStack：基于数组实现的栈

# 队列

**package queue：**

- ArrayQueue：基于数组实现的有界队列
- CircularQueue：基于数组的循环队列
- ConcurrentBlockQueue：基于重入锁实现的循环阻塞并发安全有界队列
- CasConcurrentQueue：基于CAS实现的无锁并发安全循环有界队列

# 排序

**何为原地排序算法？**

空间复杂度为O(1)的排序算法。

**何为稳定排序算法？**

两个相同大小的数据，在经过排序以后，位置顺序不变，该排序算法即为稳定排序算法。

**何为有序度？**

有序度是数组中具有有序关系的元素对的个数。如数组元素为：2,4,3,1,5,6

有序元素对为11个，分别是：(2,4),(2,3),(2,5),(2,6),(4,5),(4,6),(3,5),(3,6),(1,5),(1,6),(5,6)

**何为满有序度？**

完全有序的数组的有序度为满有序度。

满有序度 = n*(n-1)/2，其中n为数组元素的个数。

**何为逆有序度？**

逆有序度 = 满有序度 - 有序度。



### 排序算法实现

冒泡排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**稳定原地排序算法**。

插入排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**稳定原地排序算法**。

选择排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**非稳定原地排序算法**。

归并排序是**空间复杂度为O(n)**，**时间复杂度为O(nlogn)**的**(稳定/非稳定)非原地排序算法**。

**package sort下：**

- Sort.bubbleSort：冒泡排序实现
- Sort.insertionSort：冒泡排序实现
- Sort.selectionSort：选择排序实现
- Sort.mergeSort：归并排序实现