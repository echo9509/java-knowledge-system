|功能|包名.类名||类型|解法|
|---|---|---|---|---|
|数组中重复的数字|offer.DuplicateNumberInArray|数组|HashSet|
|二维数组中的查找|offer.MatrixSearch|数组|下标移动，尽可能缩小下标移动的范围|
|替换空格|offer.SpacesReplace|数组|字符串拆成数组处理|
|重建二叉树|offer.BTreeRebuild|数组|递归分别处理左子树右子树（中序遍历定位左右子树长度，前序遍历定位子树根节点）|
|斐波那契数列|offer.FibonacciSequence|动态规划|递推关系，使用动态规划|
|青蛙跳台阶问题|offer.FrogJumpStep|动态规划|递推关系，使用动态规划|
|旋转数组的最小数字|offer.RotateArrayMinNumber|数组|二分查找|


# offer
- DuplicateNumberInArray：


# LeetCode

1. MinStack：剑指Offer 30.定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)
2. Solution：剑指Offer 06.从尾到头打印链表，输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
3. Offer24：剑指Offer 24.反转链表，定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
4. Offer35：剑指Offer 35.复杂链表的复制，实现copyRandomList函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个next指针指向下一个节点，还有一个random
   指针指向链表中的任意节点或者null

# 链表

关于链表解题思路：

- 快慢指针
- 哨兵节点减少代码复杂度
- 注意链表的头尾边界
- 手动画出next节点的变化关系

**package list下：**

- LRUByLinkList：基于单向链表实现的LRU淘汰算法
- PalindromeByLinedList：基于链表实现的回文字符串检测
- ReservedLinkedList：反置链表
- MergeOrderLinkedList：两个有序链表合并
- RingInLinkedList：检测链表中是否有环
- RemoveNodeInLinkedList：删除链表中倒数第N个节点
- GetMidNodeInLinkedList：求链表的中间节点

# 栈

数组实现的栈成为顺序栈，链表实现的栈为链式栈。

**栈的应用场景**

- 函数调用
- 表达式求值
- 括号匹配
- 浏览器的前进后退（两个栈）

**表达式求值运用栈？**

对于加减乘除四则运算，我们人可以很清楚的知道如何计算，但是对于编译器来说并没有那么简单。编译器需要维护两个栈：

- 操作数栈
- 运算符栈

从左往右遍历表达式，遇到数字将其压入操作数栈，但当遇到运算符时需要将该运算符与栈顶的运算符进行比较：

- 如果该运算符比栈顶的优先级高，那么将运算符入栈
- 如果该运算符和栈顶的优先级相同或者比它第，就需要从运算符栈取出栈顶元素，然后从操作数栈取出两个操作数，进行计算，
将计算后的结果再压入操作数栈，继续比较


**package stack下：**

- ArrayStack：基于数组实现的栈

# 队列

**package queue：**

- ArrayQueue：基于数组实现的有界队列
- CircularQueue：基于数组的循环队列
- ConcurrentBlockQueue：基于重入锁实现的循环阻塞并发安全有界队列
- CasConcurrentQueue：基于CAS实现的无锁并发安全循环有界队列

# 排序

**何为原地排序算法？**

空间复杂度为O(1)的排序算法。

**何为稳定排序算法？**

两个相同大小的数据，在经过排序以后，位置顺序不变，该排序算法即为稳定排序算法。

**何为有序度？**

有序度是数组中具有有序关系的元素对的个数。如数组元素为：2,4,3,1,5,6

有序元素对为11个，分别是：(2,4),(2,3),(2,5),(2,6),(4,5),(4,6),(3,5),(3,6),(1,5),(1,6),(5,6)

**何为满有序度？**

完全有序的数组的有序度为满有序度。

满有序度 = n*(n-1)/2，其中n为数组元素的个数。

**何为逆有序度？**

逆有序度 = 满有序度 - 有序度。


### 排序算法实现

冒泡排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**稳定原地排序算法**。

插入排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**稳定原地排序算法**。

选择排序是**空间复杂度为O(1)**，**时间复杂度为O(n²)**的**非稳定原地排序算法**。

归并排序是**空间复杂度为O(n)**，**时间复杂度为O(nlogn)**的**(稳定/非稳定)非原地排序算法**。

快速排序是**空间复杂度为O(1)**，**时间复杂度为O(nlogn)**的**稳定原地排序算法**。


**package sort下：**

- Sort.bubbleSort：冒泡排序实现
- Sort.insertionSort：冒泡排序实现
- Sort.selectionSort：选择排序实现
- Sort.mergeSort：归并排序实现
- Sort.quickSort：快速排序实现
- Sort.countingSort：计数排序